# -*- coding: utf-8 -*-
"""stock-model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/151HlfQHCvMe295_33DvlVIb6CEwI8bod
"""

# !pip install --quiet ta yfinance xgboost pytrends scikit-learn matplotlib

# %% --------------------------------------------------------------------------
# 0. IMPORTY & PARAMETRY GLOBALNE
# --------------------------------------------------------------------------
import pandas as pd
import numpy as np
import yfinance as yf
import json
from ta.momentum import RSIIndicator
from ta.trend import MACD
from ta.volatility import BollingerBands
from sklearn.metrics import mean_absolute_error, mean_squared_error
from xgboost import XGBRegressor
import matplotlib.pyplot as plt
from datetime import timedelta, datetime
from pytrends.request import TrendReq
import requests

# >>>>>>>>>>>>>>>>>>>>  PARAMETRY  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
TICKER         = "AAPL"
START_DATE     = "2017-01-01"    # początek historii do trenowania
TEST_SIZE_PCT  = 0.15            # % danych na test
FORECAST_DAYS  = 14              # ile dni naprzód prognozujemy
HIST_WINDOW_D  = 365             # ile dni historii pokazać na wykresie
UPPER_Q        = 0.9             # górny kwantyl = BUY
LOWER_Q        = 0.1             # dolny kwantyl = SELL
RANDOM_STATE   = 42
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

# %% --------------------------------------------------------------------------
# 1. POBRANIE DANYCH (yfinance + Google Trends)
# --------------------------------------------------------------------------
raw = yf.download(TICKER, start=START_DATE, auto_adjust=False, progress=False)
raw_copy = raw.copy()
# Przekształcenie indeksu (daty) na kolumnę i konwersja do listy rekordów
raw_json_records = raw_copy.reset_index().to_dict(orient='records')

# <<< NAJPIERW UPEWNIJ SIĘ, ŻE KOLUMNY SĄ STRINGAMI >>>
if isinstance(raw_copy.columns, pd.MultiIndex):
    raw_copy.columns = ['_'.join(map(str, col)).strip() for col in raw_copy.columns]
else:
    raw_copy.columns = [str(col) for col in raw_copy.columns]

# <<< TERAZ KONWERSJA >>>
raw_json_records = raw_copy.reset_index().to_dict(orient='records')

payload = {
    "stock_data": raw_json_records
}

response = requests.post(
    "http://laravel.test/api/stock-api",
    headers={"Content-Type": "application/json"},
    data=json.dumps(payload, default=str)
)

if isinstance(raw.columns, pd.MultiIndex):
    raw.columns = raw.columns.get_level_values(0)

btc = (raw[['Close', 'Volume']]
       .rename(columns={'Close':'close','Volume':'volume'})
       .tz_localize(None))

# <<< POBRANIE GOOGLE TRENDS – z zabezpieczeniem >>>
try:
    # <<< POBRANIE GOOGLE TRENDS – z zabezpieczeniem >>>

    pytrends = TrendReq(hl='en-US', tz=360)
    pytrends.build_payload(['bitcoin'], timeframe=f'{START_DATE} {datetime.today():%Y-%m-%d}')
    gt = (pytrends.interest_over_time()
            .rename(columns={'bitcoin':'gt_bitcoin'})
            .drop(columns=['isPartial'])
            .resample('D').ffill())
    gt.index = gt.index.tz_localize(None)

    btc = (pd.concat([btc, gt], axis=1).ffill())   # wypełniamy ewent. luki
    GT_AVAILABLE = True
except Exception as e:
    print(f"[!] Google Trends NIE dostępny – pomijam (błąd: {e})")
    btc['gt_bitcoin'] = np.nan  # dodajemy pustą kolumnę aby make_features() nie wywalił się
    GT_AVAILABLE = False

# %% --------------------------------------------------------------------------
# 2. FEATURE ENGINEERING
# --------------------------------------------------------------------------
def make_features(df: pd.DataFrame) -> pd.DataFrame:
    out = df.copy()
    out['ret_1']  = np.log(out['close']).diff()
    out['ret_7']  = np.log(out['close']).diff(7)
    out['ret_30'] = np.log(out['close']).diff(30)
    rsi = RSIIndicator(out['close'], window=14)
    out['rsi_14'] = rsi.rsi()
    macd = MACD(out['close'])
    out['macd']        = macd.macd()
    out['macd_signal'] = macd.macd_signal()
    boll = BollingerBands(out['close'])
    out['bb_high']  = boll.bollinger_hband()
    out['bb_low']   = boll.bollinger_lband()
    out['bb_width'] = (out['bb_high'] - out['bb_low']) / out['close']
    out['vol_z'] = (out['volume'] - out['volume'].rolling(30).mean()) / out['volume'].rolling(30).std()

    if 'gt_bitcoin' in out.columns and not out['gt_bitcoin'].isna().all():
        out['gt_7d'] = out['gt_bitcoin'].rolling(7).mean()

    out['target'] = out['ret_1'].shift(-1)
    return out.dropna()


data = make_features(btc)

# %% --------------------------------------------------------------------------
# 3. TRAIN / TEST SPLIT  +  MODEL
# --------------------------------------------------------------------------
split_idx = int(len(data) * (1 - TEST_SIZE_PCT))
train, test = data.iloc[:split_idx], data.iloc[split_idx:]
X_train, y_train = train.drop(columns=['target']), train['target']
X_test , y_test  = test .drop(columns=['target']), test ['target']

model = XGBRegressor(
    n_estimators=600, learning_rate=0.03, max_depth=6,
    subsample=0.8, colsample_bytree=0.8,
    objective='reg:squarederror', random_state=RANDOM_STATE
).fit(X_train, y_train)

y_pred = model.predict(X_test)
mae  = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
print(f"Test MAE  : {mae:.5f}\nTest RMSE : {rmse:.5f}")

# %% --------------------------------------------------------------------------
# 4. FORECAST X dni NAPRZÓD  (dopisywane do last_prices)
# --------------------------------------------------------------------------
last_prices  = btc.copy()
future_dates = pd.bdate_range(last_prices.index[-1] + timedelta(days=1),
                              periods=FORECAST_DAYS)

for d in future_dates:
    last_prices.loc[d] = np.nan                       # placeholder
    feat = make_features(last_prices).iloc[[-1]].drop(columns=['target'])
    next_ret   = model.predict(feat)[0]
    next_price = last_prices.iloc[-2]['close'] * np.exp(next_ret)
    last_prices.at[d, 'close']      = next_price
    last_prices.at[d, 'volume']     = last_prices.iloc[-2]['volume']
    last_prices.at[d, 'gt_bitcoin'] = last_prices.iloc[-2]['gt_bitcoin']

forecast = (last_prices.loc[future_dates, ['close']]
            .rename(columns={'close':'forecast_close'}))

# %% --------------------------------------------------------------------------
# 5. SYGNAŁY BUY / SELL  (centrowanie + kwantyle)
# --------------------------------------------------------------------------
features_all = make_features(last_prices)
X_all        = features_all.drop(columns=['target'])
pred_raw     = pd.Series(model.predict(X_all), index=X_all.index)

pred_centered = pred_raw - pred_raw.mean()           # usuwamy bias

TH_UP = pred_centered.quantile(UPPER_Q)
TH_DN = pred_centered.quantile(LOWER_Q)

buy_idx_all  = pred_centered.index[pred_centered >  TH_UP]
sell_idx_all = pred_centered.index[pred_centered <  TH_DN]

# ograniczamy do okna rysowanego
end_hist   = btc.index[-1]
start_hist = end_hist - pd.Timedelta(days=HIST_WINDOW_D)
hist_prices     = btc.loc[start_hist:, 'close']
forecast_prices = forecast['forecast_close']
price_all       = pd.concat([hist_prices, forecast_prices])

buy_idx  = buy_idx_all [buy_idx_all  >= start_hist]
sell_idx = sell_idx_all[sell_idx_all >= start_hist]

# %% --------------------------------------------------------------------------
# 6. WYKRES  (historia + prognoza + sygnały)
# --------------------------------------------------------------------------
plt.figure(figsize=(13,6))
plt.plot(hist_prices.index,   hist_prices,   label=f'Cena – {HIST_WINDOW_D//30} mies.')
plt.plot(forecast_prices.index, forecast_prices,
         label=f'Prognoza +{FORECAST_DAYS} d', color='orange')

plt.scatter(buy_idx,  price_all.loc[buy_idx],  marker='^', color='green', label='BUY')
plt.scatter(sell_idx, price_all.loc[sell_idx], marker='v', color='red',   label='SELL')

plt.title(f"{TICKER} – sygnały BUY/SELL ({HIST_WINDOW_D//30} mies. + prognoza {FORECAST_DAYS} d)")
plt.xlabel("Data"); plt.ylabel("Cena [USD]")
plt.legend(); plt.tight_layout(); plt.show()

# %% --------------------------------------------------------------------------
# 7. TABELA PROGNOZY
# --------------------------------------------------------------------------
print("\nPrognoza na kolejne dni:")
print(forecast.round(2))

# %% --------------------------------------------------------------------------
# 7. BACK-TEST  – prowizje, SL/TP i ograniczenie pozycji
# --------------------------------------------------------------------------
CAPITAL0       = 100_000          # kapitał początkowy [USD]
FEE_PCT        = 0.0005           # prowizja 0,05 %
MAX_POS_PCT    = 0.30             # max 30 % kapitału na pozycję
STOP_LOSS_PCT  = 0.04             # SL  4 %
TAKE_PROF_PCT  = 0.08             # TP  8 %

# --- dane do symulacji -------------------------------------------------------
prices  = last_prices['close']                  # historia + prognoza
signal  = pd.Series(0, index=pred_centered.index)
signal[pred_centered >  TH_UP] =  1             # LONG
signal[pred_centered <  TH_DN] = -1             # SHORT

capital, pos_size, entry_price = CAPITAL0, 0.0, None
equity_curve, trade_log = [], []

for dt, sig in signal.items():                  # .items() dla pandas ≥ 2
    price = prices.loc[dt]

    # —— zarządzanie otwartą pozycją ————————————————————————————————
    if pos_size != 0:
        side     =  1 if pos_size > 0 else -1
        entry    = entry_price
        pnl_pct  = side * (price / entry - 1)

        if pnl_pct <= -STOP_LOSS_PCT or pnl_pct >= TAKE_PROF_PCT or sig == 0:
            # zamknięcie
            capital += pos_size * price
            capital -= abs(pos_size * price) * FEE_PCT

            gross_pnl = pos_size * (price - entry)
            fees      = abs(pos_size * price) * FEE_PCT
            net_pnl   = gross_pnl - fees
            hold_d    = (dt - open_dt).days

            trade_log.append((
                open_dt.date(),          # Data_otwarcia
                dt.date(),               # Data_zamknięcia
                'LONG' if side > 0 else 'SHORT',
                int(abs(pos_size)),      # Ilość
                round(entry, 2),         # Wejście
                round(price, 2),         # Wyjście
                hold_d,                  # Dni
                round(gross_pnl, 2),     # Zysk_brutto
                round(net_pnl,   2),     # Zysk_netto
                round(net_pnl / (abs(pos_size)*entry) * 100, 2),  # Zysk_%
                round(capital, 2)        # Kapitał_po
            ))
            pos_size, entry_price = 0, None

    # —— otwarcie nowej pozycji ————————————————————————————————
    if pos_size == 0 and sig != 0:
        max_dollar = capital * MAX_POS_PCT
        qty        = np.floor(max_dollar / price)
        if qty > 0:
            pos_size    = qty * sig
            entry_price = price
            open_dt     = dt
            capital    -= pos_size * price
            capital    -= abs(pos_size * price) * FEE_PCT

    # —— koniec dnia ——————————————————————————————————————————
    equity_curve.append(capital + pos_size * price)

equity_curve = pd.Series(equity_curve, index=signal.index)

# --- metryki podsumowujące ----------------------------------------------------
daily_ret = equity_curve.pct_change().fillna(0)
cagr   = (equity_curve.iloc[-1] / equity_curve.iloc[0])**(252/len(equity_curve)) - 1
sharpe = np.sqrt(252) * daily_ret.mean() / daily_ret.std()
max_dd = (equity_curve / equity_curve.cummax() - 1).min()

print(f"\n===== PODSUMOWANIE BACK-TESTU ({len(trade_log)} transakcji) =====")
print(f"CAGR            : {cagr:>6.2%}")
print(f"Sharpe (dzienny): {sharpe:>6.2f}")
print(f"Maks. obsunięcie: {max_dd:>6.2%}")

# --- wykres kapitału ----------------------------------------------------------
plt.figure(figsize=(12,4))
plt.plot(equity_curve)
plt.title("Krzywa kapitału – back-test z opłatami i SL/TP")
plt.ylabel("Kapitał [USD]"); plt.xlabel("Data"); plt.tight_layout(); plt.show()

# --- log transakcji -----------------------------------------------------------
kolumny = ["Data_otwarcia","Data_zamknięcia","Kierunek","Ilość","Wejście",
           "Wyjście","Dni","Zysk_brutto","Zysk_netto","Zysk_%","Kapitał_po"]
trades_df = pd.DataFrame(trade_log, columns=kolumny)

print("\nOstatnich 15 transakcji:")
print(trades_df.tail(15).to_string(index=False))

print("""
Legenda kolumn:
  • Data_otwarcia  – dzień wejścia w pozycję
  • Data_zamknięcia– dzień zamknięcia pozycji
  • Kierunek       – LONG (kupno) lub SHORT (sprzedaż na krótko)
  • Ilość          – liczba akcji
  • Wejście/ Wyjście – ceny transakcyjne
  • Dni            – czas utrzymania pozycji
  • Zysk_brutto    – zysk przed prowizją [$]
  • Zysk_netto     – zysk po prowizji [$]
  • Zysk_%         – zysk netto w % od nominału pozycji
  • Kapitał_po     – wartość portfela po zamknięciu transakcji
""")

